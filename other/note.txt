kubeasz部署时注意:
1. 注意修改coontroller-manager, scheduler监听地址: --address=0.0.0.0，以及增加kube-proxy的地址--metrics-bind-address 0.0.0.0
2. yum -y install python python-pip python-netaddr


k8s 1.16版本后，相关资源对象版本变更，比如deployment的apiVersion: extensions/v1beta1变成apps/v1,并且
其spec必须添加selector matchLabels属性。

Docker的数据持久化即使数据不随着container的结束而结束，数据存在于host机器上——要么存在于host的某个指定目录中（使用bind mount），要么使用docker自己管理的volume（/var/lib/docker/volumes下）。
1. 使用bind mount：docker run -it -v $(pwd)/host-dava:/container-data alpine sh
host机器的目录路径必须为全路径(准确的说需要以/或~/开始的路径)，不然docker会将其当做volume处理
如果host机器上的目录不存在，docker会自动创建该目录
如果container中的目录不存在，docker会自动创建该目录
如果container中的目录已经有内容，那么docker会使用host上的目录将其覆盖掉
2. 使用volume
volume也是绕过container的文件系统，直接将数据写到host机器上，只是volume是被docker管理的，docker下所有的volume都在host机器上的指定目录下/var/lib/docker/volumes。
docker run -it -v my-volume:/mydata alpine sh volume在host机器的目录为/var/lib/docker/volumes/my-volume/_data。此时，如果my-volume不存在，那么docker会自动创建my-volume，然后再挂载。
也可以不指定host上的volume(docker run -it -v /mydata alpine sh)，此时docker将自动创建一个匿名的volume，并将其挂载到container中的/mydata目录。
在Dockerfile中，我们也可以使用VOLUME指令来申明contaienr中的某个目录需要映射到某个volume，这表示，在docker运行时，docker会创建一个匿名的volume，并将此volume绑定到container的/foo目录中。也即，Dockerfile中的VOLUME /foo与docker run -v /foo alpine的效果一样。
需要注意的是，与bind mount不同的是，如果volume是空的而container中的目录有内容，那么docker会将container目录中的内容拷贝到volume中，但是如果volume中已经有内容，则会将container中的目录覆盖。

awk shell -a "", 里面命令如果包含特殊字符 " \ $，要用\进行转义。
